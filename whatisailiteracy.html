<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>What is AI Literacy - Interactive Particles</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            /* Deep radial gradient for depth and high-quality look */
            background: radial-gradient(circle at center, #1e293b 0%, #020617 100%);
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            cursor: pointer;
            height: 100vh;
            width: 100vw;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #instruction {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: rgba(148, 163, 184, 0.6);
            pointer-events: none;
            font-size: 0.85rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            animation: fade 4s infinite ease-in-out;
        }

        @keyframes fade {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.8; }
        }
    </style>
</head>
<body>

    <canvas id="canvas1"></canvas>
    <div id="instruction">Slash to Disperse â€¢ Click to Explore</div>

    <script>
        const canvas = document.getElementById('canvas1');
        const ctx = canvas.getContext('2d');
        
        const TARGET_URL = 'https://www.zenai.world/what-is-ai-literacy';
        let particleArray = [];
        
        // Mouse interaction object
        const mouse = {
            x: null,
            y: null,
            radius: 120 
        }

        // Setup Canvas
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        window.addEventListener('resize', function(){
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            init();
        });

        // Event Listeners
        window.addEventListener('mousemove', function(event){
            mouse.x = event.x;
            mouse.y = event.y;
        });

        window.addEventListener('touchmove', function(event){
            mouse.x = event.touches[0].clientX;
            mouse.y = event.touches[0].clientY;
        }, {passive: true});

        window.addEventListener('touchend', function(){
            mouse.x = null;
            mouse.y = null;
        });
        
        window.addEventListener('mouseout', function(){
            mouse.x = undefined;
            mouse.y = undefined;
        });

        window.addEventListener('click', function(){
            window.location.href = TARGET_URL;
        });

        class Particle {
            constructor(x, y){
                this.x = x;
                this.y = y;
                // Much smaller particles for "granular" look
                this.size = Math.random() * 1.2 + 0.5; 
                this.baseX = this.x;
                this.baseY = this.y;
                
                // Physics: Tweaked for "perfected" smoothness
                this.density = (Math.random() * 40) + 5;
                this.vx = 0; 
                this.vy = 0; 
                // Higher friction = 'slipperier' feel (carries momentum longer)
                this.friction = 0.94; 
                // Lower ease = slower, more graceful return to shape
                this.ease = 0.035; 
                
                // Colors: Hyper-bright Electric Blue & Pure White
                const isWhite = Math.random() > 0.7; // 30% white sparkles for glitter effect
                if (isWhite) {
                    this.color = 'hsla(0, 0%, 100%, 0.9)';
                } else {
                    // Tighter blue range for cohesion, very bright
                    const hue = Math.random() * 20 + 195; // 195-215 (Cyan-Azure)
                    // High lightness (60-80%) to pop against dark background
                    const lightness = Math.random() * 20 + 60; 
                    this.color = 'hsla(' + hue + ', 100%, ' + lightness + '%, 1)';
                }
            }

            draw(){
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.closePath();
                ctx.fill();
            }

            update(){
                // Calculate distance between mouse and particle
                let dx = mouse.x - this.x;
                let dy = mouse.y - this.y;
                let distance = Math.sqrt(dx * dx + dy * dy);
                let forceDirectionX = dx / distance;
                let forceDirectionY = dy / distance;
                
                let maxDistance = mouse.radius;
                let force = (maxDistance - distance) / maxDistance;
                let directionX = forceDirectionX * force * this.density;
                let directionY = forceDirectionY * force * this.density;

                // Interaction Logic
                if (distance < mouse.radius) {
                    // Stronger disperse force for the "Slash" effect
                    this.vx -= directionX * 0.8;
                    this.vy -= directionY * 0.8;
                } else {
                    // Return Logic: Smoother spring physics
                    if (this.x !== this.baseX) {
                        let dx = this.x - this.baseX;
                        this.vx -= dx * this.ease; 
                    }
                    if (this.y !== this.baseY) {
                        let dy = this.y - this.baseY;
                        this.vy -= dy * this.ease; 
                    }
                }

                // Apply velocity and friction
                this.vx *= this.friction;
                this.vy *= this.friction;
                
                this.x += this.vx;
                this.y += this.vy;
            }
        }

        function init(){
            particleArray = [];
            
            // Text Configuration
            // Draw text slightly smaller to keep it centered and elegant
            let fontSize = Math.min(canvas.width / 14, 90);
            if (canvas.width < 600) fontSize = 45;
            
            ctx.font = '800 ' + fontSize + 'px "Segoe UI", sans-serif'; 
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const text = "What is AI Literacy";
            
            // Layout Logic
            if (canvas.width < 900) {
                 ctx.fillText("What is", canvas.width/2, canvas.height/2 - fontSize * 0.6);
                 ctx.fillText("AI Literacy", canvas.width/2, canvas.height/2 + fontSize * 0.6);
            } else {
                 ctx.fillText(text, canvas.width/2, canvas.height/2);
            }

            // Extract pixel data
            const textCoordinates = ctx.getImageData(0, 0, canvas.width, canvas.height);
            ctx.clearRect(0, 0, canvas.width, canvas.height); 

            // Particle Sampling - HIGH RESOLUTION
            // Step 3 allows for extremely fine granularity
            let step = 3; 
            if (canvas.width < 600) step = 2; // Even higher density on small screens

            for (let y = 0, y2 = textCoordinates.height; y < y2; y += step){
                for (let x = 0, x2 = textCoordinates.width; x < x2; x += step){
                    // Check alpha (opacity) > 128
                    if (textCoordinates.data[(y * 4 * textCoordinates.width) + (x * 4) + 3] > 128){
                        let positionX = x;
                        let positionY = y;
                        particleArray.push(new Particle(positionX, positionY));
                    }
                }
            }
        }

        function animate(){
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Only draw lines if we haven't exceeded a performance threshold.
            // With step=3, we will likely have 4000+ particles. 
            // Disabling lines creates a cleaner "granular" look and keeps FPS smooth.
            if (particleArray.length < 2000) {
                connect();
            }

            for (let i = 0; i < particleArray.length; i++){
                particleArray[i].draw();
                particleArray[i].update();
            }
            requestAnimationFrame(animate);
        }
        
        function connect(){
            // Optimization: Limit connections if too many particles (fallback for safety)
            if (particleArray.length > 5000) return; 

            let opacityValue = 1;
            // Decreased connection distance to keep it "finely detailed" rather than messy
            const connectionDist = 25; 

            for (let a = 0; a < particleArray.length; a++){
                // Optimization: check only a subset of neighbors or use spatial hash (complex),
                // but for text < 2000 particles, O(N^2) with small constant is okay if we optimize loop
                for (let b = a; b < particleArray.length; b++){
                    // Quick reject based on X axis to save Sqrt calc
                    if (Math.abs(particleArray[a].x - particleArray[b].x) > connectionDist) continue;

                    let dx = particleArray[a].x - particleArray[b].x;
                    let dy = particleArray[a].y - particleArray[b].y;
                    let distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < connectionDist){
                        opacityValue = 1 - (distance/connectionDist);
                        
                        // Dynamic line color matching the particles
                        // We take the color of particle A but add transparency
                        ctx.strokeStyle = particleArray[a].color.replace(')', `, ${opacityValue * 0.5})`).replace('hsla', 'hsla');
                        
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(particleArray[a].x, particleArray[a].y);
                        ctx.lineTo(particleArray[b].x, particleArray[b].y);
                        ctx.stroke();
                    }
                }
            }
        }

        init();
        animate();

    </script>
</body>
</html>

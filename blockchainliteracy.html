<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blockchain Literacy - Interactive Particles</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            /* Deep radial gradient: Dark Slate/Metallic to Pure Black */
            /* Matches the 'refined' look of the AI version but with Blockchain tones */
            background: radial-gradient(circle at center, #1a202c 0%, #000000 100%);
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            cursor: pointer;
            height: 100vh;
            width: 100vw;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #instruction {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: rgba(148, 163, 184, 0.6);
            pointer-events: none;
            font-size: 0.85rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            animation: fade 4s infinite ease-in-out;
        }

        @keyframes fade {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.8; }
        }
    </style>
</head>
<body>

    <canvas id="canvas1"></canvas>
    <div id="instruction">Slash the Ledger â€¢ Click to Verify</div>

    <script>
        const canvas = document.getElementById('canvas1');
        const ctx = canvas.getContext('2d');
        
        const TARGET_URL = 'https://www.zenai.world/what-is-blockchain-literacy';
        let particleArray = [];
        
        // Mouse interaction object
        const mouse = {
            x: null,
            y: null,
            radius: 120 
        }

        // Setup Canvas
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        window.addEventListener('resize', function(){
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            init();
        });

        // Event Listeners
        window.addEventListener('mousemove', function(event){
            mouse.x = event.x;
            mouse.y = event.y;
        });

        window.addEventListener('touchmove', function(event){
            mouse.x = event.touches[0].clientX;
            mouse.y = event.touches[0].clientY;
        }, {passive: true});

        window.addEventListener('touchend', function(){
            mouse.x = null;
            mouse.y = null;
        });
        
        window.addEventListener('mouseout', function(){
            mouse.x = undefined;
            mouse.y = undefined;
        });

        window.addEventListener('click', function(){
            window.location.href = TARGET_URL;
        });

        class Particle {
            constructor(x, y){
                this.x = x;
                this.y = y;
                // Much smaller particles for "granular" look
                this.size = Math.random() * 1.2 + 0.5; 
                this.baseX = this.x;
                this.baseY = this.y;
                
                // Physics: Tweaked for "perfected" smoothness
                this.density = (Math.random() * 40) + 5;
                this.vx = 0; 
                this.vy = 0; 
                this.friction = 0.94; 
                this.ease = 0.035; 
                
                // Colors: Blockchain Theme (Silver, Electric Blue, White)
                // We use HSL strings (no alpha) so we can easily add alpha in the connect function
                const random = Math.random();
                
                if (random > 0.8) {
                    // 20% Pure White (Sparkles)
                    this.color = 'hsl(0, 0%, 100%)';
                } else if (random > 0.5) {
                    // 30% Metallic Silver
                    // HSL: 210 Hue (Blue-ish Gray), Low Saturation, High Lightness
                    this.color = 'hsl(210, 10%, 80%)';
                } else {
                    // 50% Electric Cyber Blue
                    // HSL: 195-210 Hue, Max Saturation, 60-70% Lightness
                    const hue = Math.random() * 15 + 195; 
                    const lightness = Math.random() * 10 + 60;
                    this.color = 'hsl(' + hue + ', 100%, ' + lightness + '%)';
                }
            }

            draw(){
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.closePath();
                ctx.fill();
            }

            update(){
                // Calculate distance between mouse and particle
                let dx = mouse.x - this.x;
                let dy = mouse.y - this.y;
                let distance = Math.sqrt(dx * dx + dy * dy);
                let forceDirectionX = dx / distance;
                let forceDirectionY = dy / distance;
                
                let maxDistance = mouse.radius;
                let force = (maxDistance - distance) / maxDistance;
                let directionX = forceDirectionX * force * this.density;
                let directionY = forceDirectionY * force * this.density;

                // Interaction Logic
                if (distance < mouse.radius) {
                    // Strong disperse force for the "Slash" effect
                    this.vx -= directionX * 0.8;
                    this.vy -= directionY * 0.8;
                } else {
                    // Return Logic: Smoother spring physics
                    if (this.x !== this.baseX) {
                        let dx = this.x - this.baseX;
                        this.vx -= dx * this.ease; 
                    }
                    if (this.y !== this.baseY) {
                        let dy = this.y - this.baseY;
                        this.vy -= dy * this.ease; 
                    }
                }

                // Apply velocity and friction
                this.vx *= this.friction;
                this.vy *= this.friction;
                
                this.x += this.vx;
                this.y += this.vy;
            }
        }

        function init(){
            particleArray = [];
            
            // Text Configuration
            // Optimized size for "Blockchain Literacy"
            let fontSize = Math.min(canvas.width / 13, 85);
            if (canvas.width < 600) fontSize = 42;
            
            ctx.font = '800 ' + fontSize + 'px "Segoe UI", sans-serif'; 
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const text = "Blockchain Literacy";
            
            // Layout Logic - Split lines for mobile/smaller screens
            if (canvas.width < 950) {
                 ctx.fillText("Blockchain", canvas.width/2, canvas.height/2 - fontSize * 0.65);
                 ctx.fillText("Literacy", canvas.width/2, canvas.height/2 + fontSize * 0.65);
            } else {
                 ctx.fillText(text, canvas.width/2, canvas.height/2);
            }

            // Extract pixel data
            const textCoordinates = ctx.getImageData(0, 0, canvas.width, canvas.height);
            ctx.clearRect(0, 0, canvas.width, canvas.height); 

            // Particle Sampling - HIGH RESOLUTION
            // Step 3 allows for extremely fine granularity
            let step = 3; 
            if (canvas.width < 600) step = 2; // Even higher density on small screens

            for (let y = 0, y2 = textCoordinates.height; y < y2; y += step){
                for (let x = 0, x2 = textCoordinates.width; x < x2; x += step){
                    // Check alpha (opacity) > 128
                    if (textCoordinates.data[(y * 4 * textCoordinates.width) + (x * 4) + 3] > 128){
                        let positionX = x;
                        let positionY = y;
                        particleArray.push(new Particle(positionX, positionY));
                    }
                }
            }
        }

        function animate(){
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Performance check: Only connect lines if comfortable
            if (particleArray.length < 2200) {
                connect();
            }

            for (let i = 0; i < particleArray.length; i++){
                particleArray[i].draw();
                particleArray[i].update();
            }
            requestAnimationFrame(animate);
        }
        
        function connect(){
            // Safety cap
            if (particleArray.length > 5000) return; 

            let opacityValue = 1;
            const connectionDist = 25; 

            for (let a = 0; a < particleArray.length; a++){
                for (let b = a; b < particleArray.length; b++){
                    // Quick reject
                    if (Math.abs(particleArray[a].x - particleArray[b].x) > connectionDist) continue;

                    let dx = particleArray[a].x - particleArray[b].x;
                    let dy = particleArray[a].y - particleArray[b].y;
                    let distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < connectionDist){
                        opacityValue = 1 - (distance/connectionDist);
                        
                        // Dynamic line color: Convert HSL to HSLA
                        // This matches the line color to the particle color
                        ctx.strokeStyle = particleArray[a].color.replace('hsl', 'hsla').replace(')', `, ${opacityValue * 0.5})`);
                        
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(particleArray[a].x, particleArray[a].y);
                        ctx.lineTo(particleArray[b].x, particleArray[b].y);
                        ctx.stroke();
                    }
                }
            }
        }

        init();
        animate();

    </script>
</body>
</html>
